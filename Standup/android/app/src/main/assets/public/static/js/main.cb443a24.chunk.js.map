{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5 lazy /^/.*/.entry/.js$/ include: /.entry/.js$/ exclude: /.system/.entry/.js$/ groupOptions: {} namespace object","../node_modules/ionicons/dist/esm-es5 lazy /^/.*/.entry/.js$/ include: /.entry/.js$/ exclude: /.system/.entry/.js$/ groupOptions: {} namespace object","firebaseServices.tsx","opentokServices.tsx","pages/Home.tsx","pages/Login.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","keys","Object","module","exports","currentUser","googleAuthProvider","firebase","GoogleAuthProvider","firebaseConfig","db","firebaseLogin","signInWithRedirect","firebaseLogout","collection","doc","uid","update","signOut","useFirebaseUser","useState","user","setUser","useEffect","onAuthStateChanged","get","docSnapshot","exists","displayName","set","addUserToFirestore","useDatabase","collectionID","docID","fieldID","fieldData","setFieldData","onSnapshot","snapshot","newData","data","undefined","OpenTok","require","OTClient","apiKey","process","REACT_APP_OPENTOK_API_KEY","apiSecret","REACT_APP_OPENTOK_API_SECRET","OT","sessionsMap","Map","makeSession","createSession","mediaMode","error","session","console","log","sessionID","sessionId","tempMap","dummySession","clientSessions","publisher","subscriber","publisherConnectionID","addSessionToFirestore","size","connectToSession","isPublisher","getClientSession","addSession","initSession","token","generateToken","on","connectionCreated","event","connection","connectionId","connectionDestroyed","disconnect","sessionDisconnected","reason","alert","streamCreated","subscribe","stream","streamDestroyed","delete","publisherID","connect","message","allUsersInSession","unsubscribe","unpublish","getPublisher","tempClientSession","SessionObj","Home","users","setUsers","where","allDocs","docs","Set","forEach","add","arr","Array","from","toString","useUsersInSession","allSessions","setCollection","useCollection","connectionID","setPublisherConnectionID","email","onClick","initPublisher","insertMode","resolution","frameRate","publish","publishSession","key","Login","App","path","component","exact","render","to","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"ygBAAA,IAAIA,EAAM,CACT,8BAA+B,CAC9B,IACA,GAED,uBAAwB,CACvB,IACA,GAED,uBAAwB,CACvB,IACA,GAED,0BAA2B,CAC1B,IACA,IAED,6BAA8B,CAC7B,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,wBAAyB,CACxB,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,sBAAuB,CACtB,IACA,IAED,uBAAwB,CACvB,IACA,IAED,4BAA6B,CAC5B,IACA,IAED,uBAAwB,CACvB,IACA,IAED,qBAAsB,CACrB,IACA,IAED,mCAAoC,CACnC,IACA,IAED,uBAAwB,CACvB,IACA,IAED,+BAAgC,CAC/B,IACA,IAED,wBAAyB,CACxB,IACA,IAED,yBAA0B,CACzB,IACA,IAED,wBAAyB,CACxB,IACA,IAED,uBAAwB,CACvB,IACA,GAED,uBAAwB,CACvB,IACA,IAED,yBAA0B,CACzB,IACA,GAED,8BAA+B,CAC9B,IACA,IAED,yBAA0B,CACzB,IACA,IAED,uBAAwB,CACvB,IACA,IAED,6BAA8B,CAC7B,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,+BAAgC,CAC/B,IACA,IAED,yBAA0B,CACzB,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,yBAA0B,CACzB,IACA,IAED,yBAA0B,CACzB,IACA,IAED,4BAA6B,CAC5B,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,uBAAwB,CACvB,IACA,IAED,sBAAuB,CACtB,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,uBAAwB,CACvB,IACA,IAED,wBAAyB,CACxB,IACA,IAED,gCAAiC,CAChC,IACA,KAGF,SAASC,EAAoBC,GAC5B,IAAIC,EAAoBC,EAAEJ,EAAKE,GAC9B,OAAOG,QAAQC,UAAUC,MAAK,WAC7B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBP,EAAM,KAEjD,MADAM,EAAEE,KAAO,mBACHF,KAIR,IAAIG,EAAMX,EAAIE,GAAMU,EAAKD,EAAI,GAC7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","file":"static/js/main.cb443a24.chunk.js","sourcesContent":["var map = {\n\t\"./ion-action-sheet.entry.js\": [\n\t\t548,\n\t\t5\n\t],\n\t\"./ion-alert.entry.js\": [\n\t\t549,\n\t\t6\n\t],\n\t\"./ion-app_8.entry.js\": [\n\t\t550,\n\t\t7\n\t],\n\t\"./ion-avatar_3.entry.js\": [\n\t\t551,\n\t\t18\n\t],\n\t\"./ion-back-button.entry.js\": [\n\t\t552,\n\t\t19\n\t],\n\t\"./ion-backdrop.entry.js\": [\n\t\t553,\n\t\t43\n\t],\n\t\"./ion-button_2.entry.js\": [\n\t\t554,\n\t\t20\n\t],\n\t\"./ion-card_5.entry.js\": [\n\t\t555,\n\t\t21\n\t],\n\t\"./ion-checkbox.entry.js\": [\n\t\t556,\n\t\t22\n\t],\n\t\"./ion-chip.entry.js\": [\n\t\t557,\n\t\t23\n\t],\n\t\"./ion-col_3.entry.js\": [\n\t\t558,\n\t\t44\n\t],\n\t\"./ion-datetime_3.entry.js\": [\n\t\t559,\n\t\t10\n\t],\n\t\"./ion-fab_3.entry.js\": [\n\t\t560,\n\t\t24\n\t],\n\t\"./ion-img.entry.js\": [\n\t\t561,\n\t\t45\n\t],\n\t\"./ion-infinite-scroll_2.entry.js\": [\n\t\t562,\n\t\t46\n\t],\n\t\"./ion-input.entry.js\": [\n\t\t563,\n\t\t25\n\t],\n\t\"./ion-item-option_3.entry.js\": [\n\t\t564,\n\t\t26\n\t],\n\t\"./ion-item_8.entry.js\": [\n\t\t565,\n\t\t27\n\t],\n\t\"./ion-loading.entry.js\": [\n\t\t566,\n\t\t28\n\t],\n\t\"./ion-menu_3.entry.js\": [\n\t\t567,\n\t\t29\n\t],\n\t\"./ion-modal.entry.js\": [\n\t\t568,\n\t\t8\n\t],\n\t\"./ion-nav_2.entry.js\": [\n\t\t569,\n\t\t15\n\t],\n\t\"./ion-popover.entry.js\": [\n\t\t570,\n\t\t9\n\t],\n\t\"./ion-progress-bar.entry.js\": [\n\t\t571,\n\t\t30\n\t],\n\t\"./ion-radio_2.entry.js\": [\n\t\t572,\n\t\t31\n\t],\n\t\"./ion-range.entry.js\": [\n\t\t573,\n\t\t32\n\t],\n\t\"./ion-refresher_2.entry.js\": [\n\t\t574,\n\t\t11\n\t],\n\t\"./ion-reorder_2.entry.js\": [\n\t\t575,\n\t\t17\n\t],\n\t\"./ion-ripple-effect.entry.js\": [\n\t\t576,\n\t\t47\n\t],\n\t\"./ion-route_4.entry.js\": [\n\t\t577,\n\t\t33\n\t],\n\t\"./ion-searchbar.entry.js\": [\n\t\t578,\n\t\t34\n\t],\n\t\"./ion-segment_2.entry.js\": [\n\t\t579,\n\t\t35\n\t],\n\t\"./ion-select_3.entry.js\": [\n\t\t580,\n\t\t36\n\t],\n\t\"./ion-slide_2.entry.js\": [\n\t\t581,\n\t\t48\n\t],\n\t\"./ion-spinner.entry.js\": [\n\t\t582,\n\t\t13\n\t],\n\t\"./ion-split-pane.entry.js\": [\n\t\t583,\n\t\t49\n\t],\n\t\"./ion-tab-bar_2.entry.js\": [\n\t\t584,\n\t\t37\n\t],\n\t\"./ion-tab_2.entry.js\": [\n\t\t585,\n\t\t16\n\t],\n\t\"./ion-text.entry.js\": [\n\t\t586,\n\t\t38\n\t],\n\t\"./ion-textarea.entry.js\": [\n\t\t587,\n\t\t39\n\t],\n\t\"./ion-toast.entry.js\": [\n\t\t588,\n\t\t40\n\t],\n\t\"./ion-toggle.entry.js\": [\n\t\t589,\n\t\t12\n\t],\n\t\"./ion-virtual-scroll.entry.js\": [\n\t\t590,\n\t\t50\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 261;\nmodule.exports = webpackAsyncContext;","var map = {\n\t\"./ion-icon.entry.js\": [\n\t\t594,\n\t\t57\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 263;\nmodule.exports = webpackAsyncContext;","\r\nimport * as firebase from 'firebase/app';\r\nimport 'firebase/auth';\r\nimport 'firebase/firestore';\r\nimport { useEffect, useState } from 'react';\r\nimport { forEachChild } from 'typescript';\r\nimport firebaseConfig from './firebaseConfig.json';\r\nconst googleAuthProvider = new firebase.auth.GoogleAuthProvider();\r\n\r\nfirebase.initializeApp(firebaseConfig);\r\n\r\nvar currentUser: firebase.User | null; // Stores the current user in a firebase.User object\r\n\r\nconst db = firebase.firestore();\r\n\r\n\r\n// Login with Google Auth\r\nfunction firebaseLogin() {\r\n    firebase.auth().signInWithRedirect(googleAuthProvider) \r\n}\r\n\r\n// Logout function\r\nfunction firebaseLogout() {\r\n    db.collection(\"users\").doc(currentUser?.uid).update({\r\n        \"OTToken\": \"null\",\r\n        \"currentSessionID\": \"null\",\r\n        \"isPublisher\" : false,\r\n        \"connectionID\": \"null\"\r\n    });\r\n    firebase.auth().signOut();\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n// Adds a user to the 'users' collection in Firestore\r\nfunction addUserToFirestore(user: firebase.User | null) {\r\n    if (user) {\r\n        db.collection('users').doc(user?.uid).get().then((docSnapshot) => {\r\n            if (docSnapshot.exists) {\r\n                db.collection('users').doc(user?.uid).update({\r\n                    \"displayName\": user?.displayName,\r\n                });\r\n                //console.log(\"updated user in database\");\r\n            }\r\n            else {\r\n                db.collection('users').doc(user?.uid).set({\r\n                    \"displayName\": user?.uid,\r\n                    \"OTToken\": \"null\",\r\n                    \"currentSessionID\": \"null\",\r\n                    \"isPublisher\": false,\r\n                    \"connectionID\": \"null\",\r\n                });\r\n                //console.log(\"added user to database\");\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Returns a firebase.User object (might be null, so use with ? operator cautiously)\r\nfunction useFirebaseUser() {\r\n    const [user, setUser] = useState(null as firebase.User | null);\r\n    useEffect(() => {\r\n        firebase.auth().onAuthStateChanged(user => {\r\n            user ? setUser(user) : setUser(null);\r\n            addUserToFirestore(user);\r\n        });\r\n    }, []);\r\n    \r\n    currentUser = user;\r\n    return user;\r\n}\r\n\r\n \r\n// Custom react Hook function \r\nfunction useDatabase(collectionID, docID, fieldID) {\r\n    //console.log(\"collection: \" + collectionID + \" | doc: \" + docID + \" | field: \" + fieldID);\r\n    const [fieldData, setFieldData] = useState(\"null\");\r\n    useEffect(() => {\r\n        db.collection(collectionID).doc(docID).onSnapshot((snapshot) => {\r\n            const newData = snapshot.data();\r\n            //console.log(newData);\r\n            \r\n            if (newData != undefined) {\r\n                setFieldData(newData[fieldID]); \r\n\r\n                \r\n            }\r\n            \r\n        });\r\n            \r\n         \r\n\r\n    }, [collectionID, docID, fieldID]);\r\n    //console.log(\"fieldData: \" + fieldData);\r\n\r\n    \r\n\r\n    return fieldData;\r\n}\r\n\r\n// Returns an entire collection from firebase firestore\r\nfunction useCollection(collectionID) {\r\n    const [collection, setCollection] = useState(undefined as firebase.firestore.QueryDocumentSnapshot<firebase.firestore.DocumentData>[] | undefined);\r\n  \r\n    useEffect(() => {\r\n      db.collection(collectionID).onSnapshot((snapshot) => {\r\n        const allDocs = snapshot.docs;\r\n        setCollection(allDocs);\r\n      });\r\n  \r\n    }, [collectionID]);\r\n    \r\n    return collection;\r\n}\r\n\r\n// Returns collection of all users in a session\r\nfunction useUsersInSession(sessionID) {\r\n    const [users, setUsers] = useState<string[]>([]);\r\n  \r\n    useEffect(() => {\r\n      db.collection(\"users\").where(\"currentSessionID\", \"==\", sessionID).onSnapshot((snapshot) => {\r\n        const allDocs = snapshot.docs;\r\n        let set = new Set<string>();\r\n        allDocs.forEach((doc) => {\r\n            const newData = doc.data();\r\n            if (newData != undefined) {\r\n                set.add(newData[\"connectionID\"]);\r\n            }\r\n        })\r\n        let arr = Array.from(set);\r\n        console.log(\"SessionID: \" + sessionID + \" | [\" + arr.toString() + \"]\");\r\n        setUsers(arr);\r\n      });\r\n  \r\n    }, [sessionID]);\r\n    \r\n    return users;\r\n}\r\n\r\nexport {\r\n    firebaseLogin,\r\n    firebaseLogout,\r\n    useFirebaseUser,\r\n    useDatabase,\r\n    useCollection,\r\n    useUsersInSession,\r\n    db,\r\n    currentUser,\r\n}\r\n\r\n\r\n","import { db } from './firebaseServices';\r\n\r\nvar OpenTok = require('opentok');\r\nvar OTClient = require('@opentok/client');\r\n\r\nconst apiKey = process.env.REACT_APP_OPENTOK_API_KEY;\r\nconst apiSecret = process.env.REACT_APP_OPENTOK_API_SECRET;\r\n\r\nvar OT = new OpenTok(apiKey, apiSecret);\r\n\r\n\r\n\r\n// Define our own object type for OpenTok Session objects\r\ntype OTClientSession = {publish: (arg0: any, arg1: (error: any) => void) => void,\r\n  on: (arg0: string, arg1: ((event: any) => void) | undefined) => void,\r\n  subscribe: (arg0: any) => void,\r\n  connect: (arg0: any, arg1: (error: any) => void) => void,\r\n  disconnect: () => void\r\n} | undefined;\r\n\r\ntype OTPublisher = { on: (arg0: string, arg1: (event: any) => void) => void; };\r\n\r\ninterface Session {\r\n  clientSessions: Map<string, OTClientSession>,\r\n  publisher: OTPublisher | undefined,\r\n  subscriber: any,\r\n  publisherConnectionID: string,\r\n}\r\n\r\nlet sessionsMap = new Map();\r\n\r\n// Sets the client's publisherConnectionID to the input, needed for disconnect logic\r\nfunction setPublisherConnectionID(sessionID, publisherConnectionID) {\r\n  if (sessionsMap.get(sessionID) != undefined) {\r\n    sessionsMap.get(sessionID).publisherConnectionID = publisherConnectionID;\r\n    console.log(\"Set publisher connection id: \" + publisherConnectionID)\r\n  }\r\n}\r\n\r\n// Makes an OpenTok session server-side\r\nfunction makeSession(uid) {\r\n  \r\n  OT.createSession({mediaMode: \"routed\"}, function(error, session) {\r\n    if (error) return console.log(error);\r\n    \r\n    var sessionID = session.sessionId;\r\n\r\n  \r\n    console.log(\"sessionID: \" + sessionID)\r\n    \r\n    //Adding an undefined instance of a Client-side session for future use, identifiable by the sessionID\r\n    var tempMap = new Map<string, OTClientSession>();\r\n    tempMap.set(\"\", undefined);\r\n    var dummySession:Session = {clientSessions: tempMap, publisher: undefined, subscriber: undefined, publisherConnectionID: \"null\"};\r\n    sessionsMap.set(sessionID, dummySession);\r\n\r\n    addSessionToFirestore(sessionID);\r\n\r\n    console.log(\"Map size:\" + sessionsMap.size);\r\n    connectToSession(uid, sessionID, true);\r\n\r\n    db.collection('users').doc(uid).update({isPublisher: true});\r\n    \r\n    \r\n  }); \r\n  \r\n}\r\n\r\n\r\n\r\n// Publishes an audio-video feed to the session\r\nfunction publishSession(uid, sessionID) {\r\n  if (sessionID == \"null\") {\r\n    return console.log(\"Cannot publish session: \" + sessionID);\r\n  }\r\n  if (sessionsMap.get(sessionID).publisher) {\r\n    return console.log(\"Cannot publish more than once!\");\r\n  }\r\n  //Adds a client-session for the publisher to our own Session interface identified by the sessionID\r\n  addSession(uid, sessionID);\r\n  \r\n  var session = getClientSession(uid, sessionID);\r\n  \r\n  var publisher = OTClient.initPublisher({insertMode: \"after\"}, {resolution: '1280x720', frameRate: 30});\r\n  sessionsMap.get(sessionID).publisher = publisher;\r\n\r\n  try {\r\n    if (session != undefined) {\r\n      session.publish(publisher, function(error) {\r\n        if (error) console.log(error);\r\n        else console.log(\"Publishing Session\");\r\n      });\r\n      publisher.on('streamCreated', function (event) {\r\n        console.log('The publisher started streaming.');\r\n        \r\n      });\r\n    }\r\n    else console.log(\"Unable to Publish!\")\r\n  } catch (e) {\r\n      console.log(\"Unable to Publish due to error!\");\r\n  };\r\n\r\n  \r\n}\r\n\r\n\r\n// Connects and subscribes user to a session on client-side\r\n\r\nfunction connectToSession(uid, sessionID, isPublisher) {\r\n  if (sessionID == \"null\") {\r\n    return console.log(\"Unable to connect to session: \" + sessionID);\r\n  }\r\n  \r\n  //using our own Session object and sessionsMap\r\n  if (sessionsMap.get(sessionID) != undefined && sessionsMap.get(sessionID).clientSessions != undefined && getClientSession(uid, sessionID) != undefined) {\r\n    return console.log(\"Already connected to this session!!!\");\r\n  }\r\n  else if (sessionsMap.get(sessionID) == undefined) {\r\n    addSession(uid, sessionID);\r\n    console.log(\"inside if\");\r\n  } \r\n  else if (sessionsMap.get(sessionID).clientSessions == undefined) {\r\n    var tempMap = new Map<string, OTClientSession>();\r\n    tempMap.set(uid, OTClient.initSession(apiKey, sessionID));\r\n    sessionsMap.get(sessionID).clientSessions = tempMap;\r\n    console.log(\"inside else if\");\r\n  }\r\n  else {\r\n    sessionsMap.get(sessionID).clientSessions.set(uid, OTClient.initSession(apiKey, sessionID)); // Adds another client session to our Session object in sessionMaps\r\n  }\r\n\r\n  var session = getClientSession(uid, sessionID);\r\n  var token = OT.generateToken(sessionID);\r\n\r\n  session.on({\r\n    connectionCreated: function (event) {\r\n      //console.log(getNumConnected(sessionID) + ' connections.');\r\n      console.log(\"ConnectionCreatedEvent: ConnectionID:\" + event.connection.connectionId);\r\n    },\r\n    connectionDestroyed: function (event) {\r\n      //console.log(getNumConnected(sessionID) + ' connections.');\r\n      // Updates relavent firebase info\r\n      var publisherConnectionID = sessionsMap.get(sessionID).publisherConnectionID;\r\n      console.log(event.connection.connectionId +  \" | \" + publisherConnectionID)\r\n      if ((event.connection.connectionId === publisherConnectionID)) {\r\n        db.collection(\"users\").doc(uid).update({\r\n          \"OTToken\": \"null\",\r\n          \"currentSessionID\": \"null\",\r\n          \"isPublisher\": false,\r\n          \"connectionID\": \"null\"\r\n        });\r\n        session.disconnect();\r\n        console.log(\"Updated All Users\");\r\n      }\r\n      \r\n\r\n      console.log(\"ConnectionDestroyedEvent: \" + event.connection.connectionId);\r\n    },\r\n    sessionDisconnected: function sessionDisconnectHandler(event) {\r\n      // The event is defined by the SessionDisconnectEvent class\r\n      console.log('Disconnected from the session.');\r\n      //document.getElementById('disconnectBtn').style.display = 'none';\r\n      if (event.reason == 'networkDisconnected') {\r\n        alert('Your network connection terminated.')\r\n      }\r\n      // Updates relavent firebase info\r\n      db.collection(\"users\").doc(uid).update({\r\n        \"OTToken\": \"null\",\r\n        \"currentSessionID\": \"null\",\r\n        \"isPublisher\": false,\r\n        \"connectionID\": \"null\"\r\n      });\r\n      \r\n    },\r\n    streamCreated: function (event) {\r\n      if (sessionsMap.get(sessionID).subscriber == undefined) {\r\n        sessionsMap.get(sessionID).subscriber = session.subscribe(event.stream);\r\n        console.log(\"subscribed to stream\");\r\n      }\r\n    }, \r\n    streamDestroyed: function(event) {\r\n      db.collection(\"sessions\").doc(sessionID).delete();\r\n      console.log(\"StreamDestroyedEvent\");\r\n    \r\n    }\r\n  });\r\n  \r\n  // Replace token with your own value:\r\n  var publisherID = \"null\";\r\n  session.connect(token, function(error) {\r\n    if (error) {\r\n      console.log('Unable to connect: ', error.message);\r\n    } else {\r\n      //document.getElementById('disconnectBtn').style.display = 'block';\r\n      console.log('Connected to the session.');\r\n      //console.log(getNumConnected(sessionID) + \" connected to this session.\");\r\n      // Updates relevant info in Firebase\r\n      db.collection('users').doc(uid).update({ \r\n        \"OTToken\": token,\r\n        \"currentSessionID\": sessionID,\r\n        \"connectionID\": session.connection.connectionId\r\n      });\r\n      if (isPublisher == true) {\r\n        db.collection(\"sessions\").doc(sessionID).update({\r\n          \"publisherConnectionID\": session.connection.connectionId,\r\n        });\r\n        publisherID = session.connection.connectionId;\r\n      }\r\n    }\r\n  });\r\n  //console.log(\"Added session: \" + sessionID + \" with \" + getNumConnected(sessionID) + \" connections.\");\r\n\r\n return publisherID;\r\n}\r\n\r\n// Disconnects user from a session and updates Firebase-Firestore data for that user\r\nfunction disconnect(uid, sessionID, isPublisher, allUsersInSession) {\r\n  if (sessionID == \"null\") {\r\n    return console.log(\"Unable to connect to session: \" + sessionID);\r\n  }\r\n  var session = getClientSession(uid, sessionID);\r\n  if (session != undefined) {\r\n\r\n    if (sessionsMap.get(sessionID).subscriber != undefined) {\r\n      session.unsubscribe(sessionsMap.get(sessionID).subscriber);\r\n      console.log(\"unsubscribed to stream\");\r\n    }\r\n\r\n    session.disconnect();\r\n    \r\n    // Updates relavent firebase info\r\n    db.collection(\"users\").doc(uid).update({\r\n      \"OTToken\": \"null\",\r\n      \"currentSessionID\": \"null\",\r\n      \"isPublisher\": false,\r\n      \"connectionID\": \"null\"\r\n    });\r\n    \r\n    if (isPublisher) {\r\n      if (sessionsMap.get(sessionID).publisher != undefined) {\r\n        session.unpublish(getPublisher(sessionID));\r\n        console.log(\"Session unpublished!\");\r\n      }\r\n      db.collection(\"sessions\").doc(sessionID).delete();\r\n    }\r\n\r\n    sessionsMap.delete(sessionID);\r\n  }\r\n\r\n  else {\r\n    console.log(\"This session is not defined, cannot disconnect!\");\r\n  }\r\n\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n// Adds a Session (defined by us) object to sessionsMap\r\nfunction addSession(uid, sessionID) {\r\n  var tempMap = new Map<string, OTClientSession>();\r\n  var tempClientSession = OTClient.initSession(apiKey, sessionID);\r\n  tempMap.set(uid, tempClientSession);\r\n  var SessionObj:Session = {clientSessions: tempMap, publisher: undefined, subscriber: undefined, publisherConnectionID: \"null\"};\r\n  sessionsMap.set(sessionID, SessionObj);\r\n}\r\n\r\n// Returns the current client session for the current user if defined\r\nfunction getClientSession(uid, sessionID) {\r\n  if (sessionsMap.get(sessionID) != undefined && sessionsMap.get(sessionID).clientSessions.get(uid) != undefined) {\r\n    return sessionsMap.get(sessionID).clientSessions.get(uid);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n// Returns the publisher of the specified session if defined\r\nfunction getPublisher(sessionID) {\r\n  if (sessionsMap.get(sessionID) != undefined) {\r\n    return sessionsMap.get(sessionID).publisher;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n\r\nfunction addSessionToFirestore(sessionID) {\r\n  if (sessionID != \"null\") {\r\n          \r\n    db.collection('sessions').doc(sessionID).set({\r\n            \"sessionID\": sessionID,\r\n            \"upvotes\": 0,\r\n            \"downvotes\": 0,\r\n            \"publisherConnectionID\" : \"null\",\r\n    });\r\n    console.log(\"added session to database\");\r\n          \r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport {\r\n  makeSession,\r\n  connectToSession,\r\n  publishSession,\r\n  disconnect,\r\n  setPublisherConnectionID,\r\n  sessionsMap\r\n}","import { IonButton, IonContent, IonPage } from '@ionic/react';\r\nimport { useEffect, useState } from 'react';\r\nimport React from 'react';\r\nimport { firebaseLogout, useFirebaseUser, useDatabase, useCollection, useUsersInSession, db} from '../firebaseServices';\r\n\r\nimport { makeSession, connectToSession, publishSession, disconnect, setPublisherConnectionID } from '../opentokServices';\r\n\r\nconst Home: React.FC = () => {\r\n\r\n  var user = useFirebaseUser();\r\n  var uid = user ? user.uid : \"null\";\r\n  var token = useDatabase(\"users\", uid, \"OTToken\");\r\n  var sessionID = useDatabase(\"users\", uid, \"currentSessionID\");\r\n  var allUsersInSession = useUsersInSession(sessionID);\r\n  var isPublisher = useDatabase(\"users\", uid, \"isPublisher\");\r\n  var allSessions = useCollection(\"sessions\");\r\n  var connectionID = useDatabase(\"users\", uid, \"connectionID\");\r\n  var upvotes = useDatabase(\"sessions\", sessionID, \"upvotes\");\r\n  var downvotes = useDatabase(\"sessions\", sessionID, \"downvotes\");\r\n  var publisherConnectionID = useDatabase(\"sessions\", sessionID, \"publisherConnectionID\");\r\n  \r\n  if (publisherConnectionID != \"null\" && sessionID != \"null\") {\r\n    setPublisherConnectionID(sessionID, publisherConnectionID);\r\n  }\r\n  else {\r\n    publisherConnectionID = \"null\";\r\n  }\r\n\r\n  return (\r\n    <IonPage>\r\n     \r\n    <IonContent>\r\n\r\n      <h1>Home</h1>\r\n      <p>UID: {uid}</p>\r\n      <p>Token: {token}</p>\r\n      <p>SessionID: {sessionID}</p>\r\n      <p>Email: {user?.email}</p>      \r\n      <p>Is connected? {(sessionID == \"null\") ? \"False\" : \"True\"}</p>\r\n      <p>Is publisher? {isPublisher ? \"True\" : \"False\"}</p>\r\n      <p>ConnectionID: {connectionID}</p>\r\n      <p>Publisher ConnnectionID: {publisherConnectionID} </p>\r\n      {/*Buttons to be implemented in final product*/}\r\n      <IonButton onClick={firebaseLogout}>Logout</IonButton>\r\n      {/*Creates a Session, should only be available if sessionID == \"null\"*/}\r\n      {(sessionID == \"null\") ? <IonButton onClick={() => {makeSession(uid)}}>Create a Session</IonButton> : console.log()}\r\n      {/*Disconnects from the user's current session, should only be available if sessionID != \"null\"*/}\r\n      {(sessionID != \"null\") ? <IonButton onClick={() => {disconnect(uid, sessionID, isPublisher, allUsersInSession);}}>Disconnect</IonButton> : console.log()}\r\n      {/*Publishes video feed to a session, should only be available if sessionID == \"null\" and if current user is a publisher*/}\r\n      {(sessionID != \"null\" && isPublisher) ? <IonButton onClick={() => {publishSession(uid, sessionID)}}>Publish Session</IonButton> : console.log()}\r\n      {/*Lists out all available sessions*/}\r\n      \r\n      <div> \r\n        <h2>All Available Sessions</h2>\r\n        {allSessions?.map((session) => {\r\n          if (session.id != \"default\")\r\n            /* Only shows the button if the user is not currently in another session */\r\n            return (<li key={session.id}>\r\n                      {(session.id == \"default\") ? console.log() : session.id}\r\n                      {(sessionID == \"null\") ? <IonButton onClick={() => connectToSession(uid, session.id, isPublisher)}>Join</IonButton> : console.log()}\r\n                    </li>\r\n            );\r\n        })}\r\n      </div>\r\n      {/* Lists out all the users in the user's current session */}\r\n      <div> \r\n        <h2>All Users in Session: {sessionID}</h2>\r\n        {\r\n            allUsersInSession.toString()\r\n        }\r\n      </div>\r\n\r\n      </IonContent>\r\n      \r\n     \r\n    </IonPage>\r\n  );\r\n};\r\n\r\n\r\nexport default Home;\r\n","import { IonButton, IonContent, IonPage } from '@ionic/react';\r\nimport React from 'react';\r\nimport { firebaseLogin } from '../firebaseServices';\r\n\r\n\r\nconst Login: React.FC = () => {\r\n\r\n  return (\r\n    <IonPage>\r\n     \r\n        <IonContent>\r\n            <h1>Login</h1>  \r\n            <IonButton onClick={firebaseLogin}>Login with Google</IonButton>\r\n        </IonContent>      \r\n     \r\n    </IonPage>\r\n  );\r\n};\r\n\r\n\r\nexport default Login;\r\n","import React from 'react';\r\nimport { Redirect, Route } from 'react-router-dom';\r\nimport { IonApp, IonRouterOutlet } from '@ionic/react';\r\nimport { IonReactRouter } from '@ionic/react-router';\r\n\r\n/*Pages Imports */\r\nimport Home from './pages/Home';\r\nimport Login from './pages/Login';\r\n\r\n\r\n/* Core CSS required for Ionic components to work properly */\r\nimport '@ionic/react/css/core.css';\r\n\r\n/* Basic CSS for apps built with Ionic */\r\nimport '@ionic/react/css/normalize.css';\r\nimport '@ionic/react/css/structure.css';\r\nimport '@ionic/react/css/typography.css';\r\n\r\n/* Optional CSS utils that can be commented out */\r\nimport '@ionic/react/css/padding.css';\r\nimport '@ionic/react/css/float-elements.css';\r\nimport '@ionic/react/css/text-alignment.css';\r\nimport '@ionic/react/css/text-transformation.css';\r\nimport '@ionic/react/css/flex-utils.css';\r\nimport '@ionic/react/css/display.css';\r\n\r\n/* Theme variables */\r\nimport './theme/variables.css';\r\nimport { useFirebaseUser } from './firebaseServices';\r\n\r\n// Firebase services initialization & configurations\r\n\r\n\r\n\r\n// Main App\r\nconst App: React.FC = () => (\r\n    \r\n    <IonApp>\r\n      <IonReactRouter>\r\n        <IonRouterOutlet>\r\n          <Route path=\"/home\" component={useFirebaseUser() ? Home : Login} exact={true} />\r\n          <Route exact path=\"/\" render={() => <Redirect to=\"/home\" />} />\r\n       \r\n        </IonRouterOutlet>\r\n      </IonReactRouter>\r\n      \r\n    </IonApp>\r\n);\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}